/**
 * ---------------------------------------------------------------------------
 * ${fileName}.ts
 * ${oneLinePurpose}
 *
 * @packageDocumentation
 *
 * @copyright  © ${year} ${org}
 * @license    MIT – see LICENSE file for details.
 * ---------------------------------------------------------------------------
 */
import path from "node:path";
import { Glob } from "bun";
import { $ } from "bun";
import { ROOT_WORKSPACE } from "../lib/constants";

interface Options {
	outDir: string;
	outFile: string;
}

const defaultOptions: Options = {
	outDir: path.resolve(import.meta.dir, "../generated"),
	outFile: "workspace.ts",
};

/* prettier console helpers ------------------------------------------------- */

const cyan = (s: string) => `\x1b[36m${s}\x1b[0m`;
const green = (s: string) => `\x1b[32m${s}\x1b[0m`;
const yellow = (s: string) => `\x1b[33m${s}\x1b[0m`;
const red = (s: string) => `\x1b[31m${s}\x1b[0m`;

function info(msg: string) {
	console.log(cyan(`[INFO] ${msg}`));
}
function success(msg: string) {
	console.log(green(`[SUCCESS] ${msg}`));
}
function warn(msg: string) {
	console.warn(yellow(`[WARN] ${msg}`));
}
function error(msg: string) {
	console.error(red(`[ERROR] ${msg}`));
}

/* ------------------------------------------------------------------------- */

export async function generateWorkspaceTypes(_opts: Partial<Options> = {}) {
	const options: Options = { ...defaultOptions, ..._opts };

	const workspaces = new Map<string, string>(); // name  -> dir
	const apps = new Map<string, string>(); // name  -> dir
	const packages = new Map<string, string>(); // name  -> dir

	info(`Scanning for package.json files under: ${ROOT_WORKSPACE}`);

	let skipped = 0;

	const glob = new Glob("**/package.json");

	for await (const match of glob.scan({
		cwd: ROOT_WORKSPACE,
		absolute: true,
		onlyFiles: true,
	})) {
		if (match.includes("node_modules")) {
			skipped++;
			continue;
		}

		const dirRel = path.relative(ROOT_WORKSPACE, path.dirname(match));
		const pkg = await Bun.file(match).json();

		workspaces.set(pkg.name, dirRel);

		if (pkg.name === "@bank-kit/root") {
			info(`Registered workspace: ${pkg.name}`);
		}

		if (dirRel.startsWith("apps/")) {
			apps.set(pkg.name, dirRel);
			info(`Registered app      : ${pkg.name}  → ${dirRel}`);
		} else if (dirRel.startsWith("packages/")) {
			packages.set(pkg.name, dirRel);
			info(`Registered package  : ${pkg.name}  → ${dirRel}`);
		}
	}

	/* ----------------------------------------------------------------------- */
	/*  Build the generated TypeScript string                                  */
	/* ----------------------------------------------------------------------- */

	const enumNames = [...workspaces.keys()]
		.map((n) => `\t"${n}" = "${n}",`)
		.join("\n");

	const assignWorkspaceType = (searchStr: string) => {
		if (searchStr === "") return "ROOT";
		if (searchStr.startsWith("apps/")) return "APP";
		if (searchStr.startsWith("packages/")) return "PACKAGE";
	};

	const mapEntries = [...workspaces.entries()]
		.map(([name, dir]) => {
			const wsType = assignWorkspaceType(dir);
			return `\t[
        "${name}",
        {
          name: "${name}",
          path: "${dir}",
          type: WorkspaceType.${wsType},
          readPackageJson: async () => Bun.file("${dir}/package.json").json()
        }
      ] as const`;
		})
		.join(",\n");

	const content = /* typescript */ `\n
	/**
    * ---------------------------------------------------------------------------
    * workspace-types.ts
    * This file is auto-generated to provide type-safe access to workspace names,
    * paths, and types for all detected workspaces in the monorepo. It enables
    * tooling and scripts to reference workspaces in a consistent, type-checked way.
    * Do not edit this file directly—run the generator script to update.
    *
    * @packageDocumentation
    * © ${new Date().getFullYear()} Bank Kit – MIT License
    * ---------------------------------------------------------------------------
    */

    export enum WorkspaceType {
      ROOT = "root",
      APP = "app",
      PACKAGE = "package",
    }

    export enum WORKSPACE_NAME {
    ${enumNames}
    }

    export type WorkspaceName = keyof typeof WORKSPACE_NAME;

    export interface WorkspaceDefinition {
      readonly name: WorkspaceName;
      readonly path: string;
      readonly type: WorkspaceType;
      readonly readPackageJson: () => Promise<unknown>;
    }

    const workspaceEntries = [
    ${mapEntries}
    ] as const satisfies readonly (readonly [WorkspaceName, WorkspaceDefinition])[];

    export const workspace = new Map<WorkspaceName, WorkspaceDefinition>(workspaceEntries);

    export const resolveWorkspace = async (name: WorkspaceName) => {
      const path = await import("node:path");
      return path.join("${path.relative(import.meta.file, ROOT_WORKSPACE)}", workspace.get(name)?.path ?? "");
    }
`;

	/* ----------------------------------------------------------------------- */
	/*  Write file                                                             */
	/* ----------------------------------------------------------------------- */

	try {
		await Bun.write(path.join(options.outDir, options.outFile), content);
		await $`bunx biome format --write ${path.join(options.outDir, options.outFile)}`;
		success(`Generated types → ${options.outDir}/${options.outFile}`);
		return { status: "success", data: { workspaces, apps, packages } };
	} catch (e) {
		error(String(e));
		return {
			status: "error",
			message: e instanceof Error ? e.message : "unknown",
		};
	}
}

/* Run directly with:  bun run scripts/generate-workspace-types.ts ---------- */
if (import.meta.main) {
	await generateWorkspaceTypes();
}
